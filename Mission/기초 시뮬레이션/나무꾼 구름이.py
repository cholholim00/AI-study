# N: 나무의 그루 수
# M: 벌목 가능한 최소 높이 (이보다 크거나 같아야 벱니다)
# x: 벌목꾼의 초기 위치 (1부터 시작하므로 코드에서 -1을 하여 0-index로 맞춤)
# H: 나무들의 초기 높이 리스트
# Q: 시뮬레이션 진행 횟수 (턴 수)
# D: 이동 방향 리스트 (L 또는 R)
# ans: 수확한 나무의 총 길이 (정답)
N, M, x = map(int, input().split())
H = list(map(int, input().split()))
Q = int(input())
D = input().split()

x -= 1 # 0-based index
ans = 0
for i in range(Q):

    # 1. 벌목할 수 있으면 벌목
    if H[x] + i >= M: # (저장된 값 + 흐른 시간)이 M 이상이면
        ans += H[x] + i # 현재 높이만큼 수확
        H[x] -= H[x] + i # 나무 높이를 0으로 만듦 (내부적으로는 -i로 저장)

    # 2. 움직이기
    if D[i] == 'L': # L이면 왼쪽으로 이동 (인덱스가 0에서 왼쪽으로 N-1이 된다.)
        x = (x - 1) % N # % N (모듈러 연산) : 원형으로 연결된 맵을 구현
    elif D[i] == 'R': # R이면 오른쪽으로 이동 (N-1에서 오른쪽으로 가면 0이 된다.)
        x = (x + 1) % N # % N (모듈러 연산) : 원형으로 연결된 맵을 구현

    # 나무들의 높이가 1씩 자라는 것을 i로 생각하면 된다.
print(ans)
